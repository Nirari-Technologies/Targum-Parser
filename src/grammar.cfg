/**
 * Targum Parser is an interpreted PEG parser!
 * 
 * 
 * Keys represent the rules of your grammar.
 * Values represent the expression of that rule.
 * ALL grammatical values must be strings.
 * 
 * The FIRST key-value will be executed, this is a TOP-DOWN Parser.
 * The PEG semantics is right-associative.
 * 
 * To execute a given rule, you wrap it around <> brackets.
 * Make sure the rule exists or you WILL be given a parsing error.
 * 
 * Sequences have a lower priority than Alternation.
 * 
 * Required tokens/strings must be wrapped in single or double quotes.
 * 
 * You can wrap grammar expressions into groups using parentheses ():
 * -- <a> ('b' | 'c')
 * 
 * Alternate rulings are done using the pipe aka vertical bar '|'
 * or the forward slash aka division sign '/':
 * -- 'a' / <b>
 * 
 * Optional expressions are done by grouping expressions into square brackets []:
 * -- [<a>]
 * 
 * Sub-expressions within an optional or group expression run as sequences.
 * 
 * Repetition is done with:
 * -- +<a> -> 1 or more <a>.
 * -- *<a> -> 0 or more <a>.
 * See PEG parsers for more information on repetition.
 * 
 * Lookahead, which doesn't consume any input, is done with:
 * -- &<a> -> positive lookahead.
 * -- !<a> -> negative lookahead.
 * 
 * To gain access to literal value tokens (like '1234' or '3.f') from a lexer,
 * use {key} which will be used to access specific literal tokens.
 * 
 * Here's an example for when you need to get an integer literal token:
 * 'rule': '{int}'
 * 
 * `targum_parser_define_token(&parser, "int", token_int_value);`
 */

"settings" {
	/// enables parser warnings.
	"warnings":            true
	
	/// threshold for how many times rules are iterated over without consuming input.
	/// if the threshold is hit, it is considered a non-deterministic infinite loop.
	"recursion threshold": 50000
	
	/// debug file output showing what rules were traversed during runtime.
	"rule tracing":        true
}

/*
'grammar': {
	"expr":      "*<expr_list>"
	"term":      "<factor>"
	"expr_list": "<expr> *(',' <expr>)"
	"id_list":   "{identifier} *(',' {identifier})"
	"factor":    "{integer} | {float} | {string} | {rune} | {identifier}"
}
*/

/*
/// Brainf*** grammar:
"grammar": {
	"start":    "*<op>",
	"op":       "<ptr> / <io> / <math> / <loop>",
	"ptr":      "'<' / '>'",
	"math":     "'+' / '-'",
	"io":       "',' / '.'",
	"loop":     "'[' *<op> ']'"
}
*/

/*
/// indirect recursive grammar, should be detected!
/// if not, parser isn't working right.
"grammar": {
	"S": "*<a> <A>",
	"A": "<B>",
	"B": "<S>",
	"a": "{integer}"
}
*/

/*
/// typical programming math grammar:
"grammar": {
	"start":   "*<sum>",
	"sum":     "<product> *( ('+' | '-') <product> )",
	"product": "<term> *( ('*' | '/' | '%') <term> )",
	"term":    "{integer} | {float}"
}
*/

///*
/// Lua's grammar.
"grammar": {
	"chunk": "*(<stat> [';']) [<laststat> [';']]"
	"block": "<chunk>",
	
	"stat":  "(<varlist> '=' <explist>)\
				| <functioncall>\
				| ('do' <block> 'end')\
				| ('while' <exp> 'do' <block> 'end')\
				| ('repeat' <block> 'until' <exp>)\
				| ('if' <exp> 'then' <block> *('elseif' <exp> 'then' <block>) ['else' <block>] 'end')\
				| ('for' <Name> '=' <exp> ',' <exp> [',' <exp>] 'do' <block> 'end')\
				| ('for' <namelist> 'in' <explist> 'do' <block> 'end')\
				| ('function' <funcname> <funcbody>)\
				| ('local' <function> <Name> <funcbody>)\
				| ('local' <namelist> ['=' <explist>])",
	
	"laststat": "'return' [<explist>] | 'break'",
	"funcname": "<Name> *('.' <Name>) [':' <Name>]",
	"varlist":  "<var> *(',' <var>)",
	"var":      "<Name> | (<prefixexp> '[' <exp> ']') | (<prefixexp> '.' <Name>)",
	"namelist": "<Name> *(',' <Name>)",
	"explist":  "*(<exp> ',') <exp>",
	"exp":      "'nil'
					| 'false'
					| 'true'
					| {integer}
					| {float}
					| {string}
					| {char}
					| '...'
					| <function>
					| <prefixexp>
					| <tableconstructor>
					| (<exp> <binop> <exp>)
					| (<unop> <exp>)",
	"prefixexp": "<var> | <functioncall> | ('(' <exp> ')')",
	"functioncall": "<prefixexp> <args> | <prefixexp> ':' <Name> <args>",
	"args":     "'(' <explist> ')' | <tableconstructor> | {string}",
	"function": "'function' <funcbody>",
	"funcbody": "'(' [<parlist>] ')' <block> 'end'",
	"parlist":  "<namelist> [',' '...'] | '...'",
	"tableconstructor": "'{' [<fieldlist>] '}'",
	"fieldlist": "<field> *(<fieldsep> <field>) [<fieldsep>]"
	"field":    "'[' <exp> ']' '=' <exp> | <Name> '=' <exp> | <exp>",
	"fieldsep": "',' | ';'",
	"binop":    "'+' | '-' | '*' | '/' | '^' | '%' | '..' | '<' | '<=' | '>' | '>=' | '==' | '~=' | 'and' | 'or'",
	"unop":     "'-' | 'not' | '#'"
	"Name":     "{identifier}"
}
//*/