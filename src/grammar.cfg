/**
 * Targum Parser is an interpreted PEG-like parser!
 * 
 * 
 * Keys represent the rules of your grammar.
 * Values represent the expression of that rule.
 * ALL grammatical values must be strings.
 * 
 * The FIRST key-value will be executed, this is a TOP-DOWN Parser.
 * The PEG semantics is right-associative.
 * 
 * To run a given production, you wrap its name around <> brackets.
 * Make sure the rule exists or you WILL be given a runtime error.
 * 
 * Sequences have a higher priority than Alternation.
 * 
 * Required tokens/strings must be wrapped in single or double quotes.
 * 
 * You can wrap grammar expressions into groups using parentheses ():
 * -- <a> ('b' | 'c')
 * Without the parentheses, it'd execute as if:
 * (<a> 'b') | 'c'
 * 
 * Alternate rulings are done using the pipe aka vertical bar '|'
 * or the forward slash aka division sign '/':
 * -- 'a' / <b> <c>
 * -- 'a' | <b> <c>
 * NOTE: Targum Parser does NOT backtrack. So if an expression eats a token,
 * it's considered gone. Knowing this, be watchful when doing alternate expressions.
 * 
 * Optional expressions are done by grouping expressions into square brackets []:
 * -- [<a> '!']
 * If an optional expression passes the first expression
 * but ultimately fails, it is considered a parsing error.
 *
 * 
 * Sub-expressions within an optional or group expression run as sequences.
 * 
 * Repetition is done with:
 * -- +<a> -> 1 or more <a>.
 * -- *<a> -> 0 or more <a>.
 * See PEG parsers for more information on repetition.
 * 
 * Lookahead, which doesn't consume any input, is done with:
 * -- &<a> -> positive lookahead.
 * -- !<a> -> negative lookahead.
 * 
 * To gain access to literal value tokens (like '1234' or '3.f') from a lexer,
 * use {key} which will be used to access specific literal tokens.
 * 
 * Here's an example for when you need to get an integer literal token:
 * 'rule': '{int}'
 * 
 * `targum_parser_define_token(&parser, "int", token_int_value);`
 */

"settings": {
	/// enables parser warnings.
	"warnings":            true
	
	/// threshold for how many times rules are iterated over without consuming input.
	/// if the threshold is hit, it is considered a non-deterministic infinite loop.
	"recursion threshold": 50000
	
	/// debug file output showing what rules were traversed during runtime.
	"rule tracing":        true
	"print rule tree":     true
	
	/// will force-make a parse tree, even if the grammar fails.
	/// not implemented.
	//"force parse tree":    false
}

///*
"grammar": {
	"start":                "<input>",
	
	"input":                "<input_program> <inputs>",
	
	"main":                 "'MAIN' <procedure_body>",
	
	"input_program":        "*<proc_decl> <main>",
	
	"proc_decl":            "'PROC' <procedure_name> <procedure_body> 'ENDPROC'",
	
	"procedure_name":       "<primary>",
	
	"procedure_body":       "+<statement>",
	
	"statement":            "&'INPUT' <input_statement> | &'OUTPUT' <output_statement> | &'PROC' <procedure_invocation> | &'DO' <do_statement> | <assign_stmt>"
	
	"output_statement":     "'OUTPUT' <name> ';'",
	
	"input_statement":      "'INPUT' <name> ';'",
	"procedure_invocation": "<procedure_name> ';'",
	"do_statement":         "'DO' <name> <procedure_invocation>",
	"assign_stmt":          "<name> '=' <expr> ';'",
	
	"expr":                 "<primary> [<operator> <primary>]",
	"operator":             "'+' | '-' | '/' | '*'",
	"primary":              "{integer} | <name>",
	"name":                 "{identifier}"
	"inputs":               "+{integer}"
}
//*/


/*
/// typical programming expression grammar:
"grammar": {
	"start":       "*( <expr stmt> | <assignment> )",
	"expr stmt":   "<expr>",
	"inc stmt":    "<expr> ('++' | '--')",
	"assignment":  "&{identifier} <exprlist> ( '=' | ':=' | '+=' | '-=' | '*=' | '/=' | '%=' | '|=' | '^=' | '&=' | '<<=' | '>>=' | '&^=' ) <exprlist>",
	"exprlist":    "<expr> *( ',' <expr> )",
	"expr":        "<logical_or>",
	"logical_or":  "<logical_and> *( '||' <logical_and> )",
	"logical_and": "<compare> *( '&&' <compare> )",
	"compare":     "<sum> *( ('==' | '!=' | '<' | '<=' | '>' | '>=') <sum> )",
	"sum":         "<product> *( ('+' | '-' | '^' | '|') <product> )",
	"product":     "<prefix> *( ('*' | '/' | '%' | '<<' | '>>' | '&' | '&^') <prefix> )",
	"prefix":      "*( '+' | '-' | '!' | '^' | '*' | '&' | '~' ) <postfix>",
	
	"field":       "('.' | '->') <postfix>",
	"type_assert": "'.' '(' <term> ')'",
	"multi index": "<expr> [ ',' <exprlist> | ':' <expr> ]",
	"postfix":     "<term> *( '[' <multi index> ']' | '(' [ <exprlist> ] ')' | <field> )",
	
	"term":        "{identifier} | {integer} | {float} | {string} | {rune} | '(' <expr> ')'"
}
*/
