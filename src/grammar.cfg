/**
 * Targum Parser is an interpreted PEG parser!
 * 
 * 
 * Keys represent the rules of your grammar.
 * Values represent the expression of that rule.
 * ALL grammatical values must be strings.
 * 
 * The FIRST key-value will be executed, this is a TOP-DOWN Parser.
 * The PEG semantics is right-associative.
 * 
 * To execute a given rule, you wrap it around <> brackets.
 * Make sure the rule exists or you WILL be given a parsing error.
 * 
 * Sequences have a higher priority than Alternation.
 * 
 * Required tokens/strings must be wrapped in single or double quotes.
 * 
 * You can wrap grammar expressions into groups using parentheses ():
 * -- <a> ('b' | 'c')
 * 
 * Alternate rulings are done using the pipe aka vertical bar '|'
 * or the forward slash aka division sign '/':
 * -- 'a' / <b>
 * -- 'a' | <b> <c>
 * 
 * Optional expressions are done by grouping expressions into square brackets []:
 * -- [<a> '!']
 * 
 * Sub-expressions within an optional or group expression run as sequences.
 * 
 * Repetition is done with:
 * -- +<a> -> 1 or more <a>.
 * -- *<a> -> 0 or more <a>.
 * See PEG parsers for more information on repetition.
 * 
 * Lookahead, which doesn't consume any input, is done with:
 * -- &<a> -> positive lookahead.
 * -- !<a> -> negative lookahead.
 * 
 * To gain access to literal value tokens (like '1234' or '3.f') from a lexer,
 * use {key} which will be used to access specific literal tokens.
 * 
 * Here's an example for when you need to get an integer literal token:
 * 'rule': '{int}'
 * 
 * `targum_parser_define_token(&parser, "int", token_int_value);`
 */

"settings": {
	/// enables parser warnings.
	"warnings":            true
	
	/// threshold for how many times rules are iterated over without consuming input.
	/// if the threshold is hit, it is considered a non-deterministic infinite loop.
	"recursion threshold": 50000
	
	/// debug file output showing what rules were traversed during runtime.
	"rule tracing":        true
	"print rule tree":     true
}

/*
/// Brainf*** grammar:
"grammar": {
	"start":    "*<op>",
	"op":       "'<' / '>' / ',' / '.' / '+' / '-' / <loop>",
	"loop":     "'[' *<op> ']'"
}
*/

///*
/// typical programming math grammar:
"grammar": {
	"start":       "*( <expr> [';'] )",
	"exprlist":    "<expr> *( ',' <expr> )",
	"expr":        "<logical_or>",
	"logical_or":  "<logical_and> *( '||' <logical_and> )",
	"logical_and": "<compare> *( '&&' <compare> )",
	"compare":     "<sum> *( ('==' | '!=' | '<' | '<=' | '>' | '>=') <sum> )",
	"sum":         "<product> *( ('+' | '-' | '^' | '|') <product> )",
	"product":     "<prefix> *( ('*' | '/' | '%' | '<<' | '>>' | '&' | '&^') <prefix> )",
	"prefix":      "*( '+' | '-' | '!' | '^' | '*' | '&' ) <postfix>",
	
	"field":       "'.' <postfix>",
	"type_assert": "'.' '(' <term> ')'",
	"multi index": "<expr> [ ',' <exprlist> | ':' <expr> ]",
	"postfix":     "<term> *( '[' <multi index> ']' | '(' [ <exprlist> ] ')' | <field> )",
	
	"term":        "{identifier} | {integer} | {float} | {string} | {rune} | '(' <expr> ')'"
}
//*/

/*
/// Lua's grammar
"grammar": {
	"statlist":    "*(<stat> [';'])",
	"fieldsel":    "['.' | ':'] <NAME>",
	"index":       "'[' <expr> ']'"
	"recfield":    "(<NAME> | <index>) '=' <expr>"
	"listfield":   "<exp>"
	
	"constructor": "'{' [ <field> *( <sep> <field> ) [<sep>] ] '}'"
	"sep":         "',' | ';'"
	"parlist":     "[ <param> *( ',' <param> ) ]"
	"param":       "<NAME> | '...'"
	"body":        "'(' <parlist> ')' <block> 'end'"
	"explist":     "<exp> *( ',' <exp> )"
	"funcargs":    "'(' [ <explist> ] ')' | <constructor> | {string}"
	"primaryexp":  "<NAME> | '(' <expr> ')'"
	"suffixedexp": "<primaryexp> *( '.' <NAME> | '[' <exp> ']' | ':' <NAME> <funcargs> | <funcargs> )"
	"simpleexp":   "{integer} | {float} | {string} | 'nil' | 'true' | 'false' | '...' | <constructor> | 'function' <body> | <suffixedexp>"
	"subexpr":     "(<simpleexp> | <unop> <subexpr>) *( <binop> <subexpr> )"
	"unop":        "'#' | '~' | '-' | 'not'"
	"binop":       "'+' | '-' | '*' | '/' | '//' | '%' | '^' | '<<' | '>>' | '&' | '|' | '~' | '<' | '<=' | '>' | '>=' | '==' | '~=' | 'and' | 'or' | '..'"
	"expr": "<subexpr>"
	
	"assignment":  "',' <suffixedexp> <assignment> | '=' <explist>"
	"cond":        "<exp>"
	"label":       "'::' <NAME> '::'"
	"forbody":     "'do' <block>"
	"fornum":      "<NAME> '=' <expr> ',' <expr> [',' <expr>] <forbody>"
	"forlist":     "<NAME> *( ',' <NAME> ) 'in' <explist> <forbody>"
	"forstat":     "'for' (<fornum> | <forlist>) 'end'"
	"test_then_block" "['if' | 'elseif'] <cond> 'then' <block>"
	"ifstat":      "'if' <cond> 'then' <block> *( 'elseif' <cond> 'then' <block> ) ['else' <block>] 'end'"
	"localstat":   "'local' <NAME> *(',' <NAME>) ['=' <explist>]"
	"funcname":    "<NAME> *<fieldsel> [':' <NAME>]"
	"funcstat":    "'function' <funcname> <body>"
	"whilestat":   "'while' <cond> 'do' <block> 'end'"
	"repeatstat":  "'repeat' <block> 'until' <cond>"
	"exprstat":    "<suffixedexp> | <assignment>"
	"retstat":     "'return' [<explist>] [';']"
	"stat":        "';' | <ifstat> | <whilestat> | 'do' <block> 'end' | <forstat> | <repeatstat> | <funcstat> | <localstat> | <label> | <retstat> | 'break' | 'goto' <NAME> | <exprstat>"
	"NAME": "{identifier}"
}
*/